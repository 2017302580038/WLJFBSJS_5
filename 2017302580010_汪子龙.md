## 作业五

#### 1.UDP校验和

python代码如下

```
//校验和计算函数
def checkSum(numbers):
    result = 0;
    for number in numbers:
        result = (result + number) % 0b10000000000000000 + (result + number) // 0b10000000000000000
    return format(result^0b1111111111111111, '016b')

//检验课本3.3.2节内容
print("校验和为：" + checkSum([0b0110011001100000,0b0101010101010101,0b1000111100001100]))
```

结果与课本计算结果相同

```
D:\Users\97207\Desktop\网络及分布式计算\作业>python checkSum.py
校验和为：1011010100111101
```



#### 2.课后习题

**Problem 3**

工作过程：

01010011+01100110=10111001

10111000+01110100=00101110

校验码为11010001

使用反码原因：使用反码，检验时最终的四个字节和相加结果为11111111，只需要检测其中不含0即可通过，便于校验

1比特的差错一定会检测出来，但是2比特的差错不一定



**Problem4**

（a）和为11000001，反码为00111110

（b）和为01000000，反码为10111111

（c）01010100和01101101